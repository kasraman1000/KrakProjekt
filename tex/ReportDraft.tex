\documentclass[a4paper,10pt,titlepage]{article}
\begin{document}
	\tableofcontents
	\newpage
	\section{Preface}
		This project and report is made by Jakob Bang Helvind, Kasra Tahmasebi Shahrebabak, Mark Thorhauge, Filip Hjermind Jensen, Lars Yndal Sørensen og
		Anders Brorup Jørgensen. It was written for the course ’First-Year Project’ on the bachelor ”Software Development” in the Spring of 2012 at the
		IT-University of Denmark. The report is written in terms, that we believe fellow students possesses and will understand. We hope that this 
		report will give insight in the workprocess as well as the product and that all readers will enjoy reading it.\\
		MAALGRUPPE !! ! 
	
	\section{Background and Data}
		length : 0.5 - 1 side\\
		For this project we have been given the task of designing and creating a java-written program 
		for the exam in the course 'First-Year-Project' on 2nd semester in the bachelorprogram. The basic idea of the 
		program is, that it should use some existing mapdata of Denmark to visualize a map of Denmark and let the user be
		able to search and see a given route. 
		\\This dataset is from the danish mapprovider Krak.dk and it consists of two text files. A file with all the points 
		and a file with all connections between these points.  
		\\The application should meet the following requirements:
		\\	- Draw all roads in the dataset
		\\	- The map-visualization should adjust acordingly to changes of the windows size
		\\	- The user should be able to navigate in the visualization
		\\	- The application should have a minimum of clutter and therefore be able to set a priority of the roads
		\\	- Be able to compute and show the shortest path between two points given by the user
		\\	- The application should have a logical, consistent and reasonable fast and responsive user interface\\
		
		In other words, a user should be able to see a map of Denmark with a selective amount of major roads, then explore
		 this map by zooming in and out, and otherwise navigating around. A user should also be able to select two adresses,
		 and get the shortest route between these two points calculated and shown on the map, with the map cut out to a
		 fitting view of the route.
	\section{Problemanalysis}
		\subsection{Requirements}
		length : 1-3 sider\\
		Analyse af de krav, som er beskrevet i foregående afsnit\\
		Hvad skal vi have med i vores program, for at vi kan indfri disse krav?\\
		Hvilke ting vil i have fokus paa - hastighed, hukommelse, brugervenlighed, udvidelsesmuligheder etc.?\\
		hvorfor har vi valgt edges og road objekter istedet for at holde det samlet?
		
		
		\subsection{Thoughts toward design}
			length : 0.5 side\\
			Opsummering af foregående afsnit omkring analyse af samt en præcisering af kravene. Men dette afsnit, skal bare bruges som indledning. 
			\subsubsection{Datastructure}
				length : 1 - 2 side\\
				Hvilke generelle overvejelser er skal der tager i forbindelse med valg af datastruktur? \\
				Hvor mange har vi brug - hvilke krav er der til hver enkelt?\\
				Hvorfor har vi valgt lige netop denne datastruktur - Hvilke af vores krav indfrier de?\\
				Alternativer - Fordele / ulemper?\\
				
				The type of the data, which should be stored in the data structure, is an important decision for the data structure itself. Either the data could be roads with two points, a type and a priority, or it could be nodes with a point and references to road 						objects that it represents. As we want to draw roads and not nodes, it would be the most memory saving decision to store roads. However roads impose a complex problem, that is when searching for them(a range search) they should be returned when 				one or two of their coordinates are within the range. When storing roads in a grid file or a kd-tree, a road would appear twice because it has two points, making it very likely to return it twice when doing a range search. A HashSet or a similar data 						structure would solve this problem, but still slowing down the searching process. To avoid this complexity, roads could be referenced at only one of their points. This removes the possibility to return the same road twice, but imposes another problem. 					The illustration below shows roads, which are stored as points(the circles at the end of the line) and a range(the thick rectangle). When searching in this range, all the roads should be returned. With roads referenced as a single point, R2 would not be 					returned, but R1 would. R3 would never be returned, even when referenced by two points. To solve this, an extra part of the map could be loaded, increasing the width and height of the rectangle by x, where x is the longest road in the map. Of 						course this would be inefficient if the roads’ length is not systematically broken down, and this would require the data to be restructured. To be able to guarantee that all roads within an area are shown, we will need to take this approach for that 						particular solution.
				The node has references to the roads that it is a part of. Storing nodes in the data structure has the same problem as storing roads referenced by two points. The difference is that nodes requires more memory because an object is created for each 					one, but it makes the construction of the data structure simpler. The node object acts as a collection for roads with a similar end points, and as roads naturally have similar endpoints, this is a suitable way to store data. As there are fewer nodes than 					road endpoints, it makes the kd-tree(discussed later in this chapter) more shallow, and therefore faster. 
				Because we did not want to restructure the data yet and we wanted to make a simple way to store the data, we chose to use Node objects as the data.
				We had several requirements for our data structure. First of all, it should be faster than linear searching through the keys of the objects and the improvement should be worth the time it takes to build the data structure when the application starts. 					When looking at smaller parts of the map the improvement should be most significant. We chose the kd-tree because its binary structure and adaptive construction makes it efficient to access data, no matter how much it clumps(how numerically close 					the keys are to each other). While grid-file is potentially faster, the kd-tree is stable and does not depend on bucket size or other factors such as cluttering. Also one of the kd-tree’s weaknesses is to return data from a rectangular query, which our 					aspect ratio does not allow, making it very suitable for our problem.
				
			\subsubsection{Algorithms}
				length : 1 - 2 side\\
				Hvilke generelle overvejelser er der ved valg af algoritmer?\
				Hvad skal vi bruge den/dem til i vores program - Hvilke problem løser de/Hvilke er vores krav indfrier de?\\
				Hvilken algoritme har vi valgt? - Hvorfor lige netop denne?\\
				Alternativer?\\
								
			\subsubsection{User Interface}
				length : 1 - 2 side\\
				Hvilke krav har vi til brugerfladen??\\
				Hvorfor bruger vi JS/Browser og ikke java Swing??\\
				
				
		\subsection{Summary}
			length : 0.5 - 1 side\\
			Opsummering\\
			Kan vi indfri vores krav/maal for programmet, ved at bruge de ting, som vi har beskrevet i det her afsnit??\\
			
	\section{Implementation}
		length : 0.5 - 1 side\\
		Her beskrives kort hvad der kommer til at være i det kommende afsnit..
		
		\subsection{Flow description}
			length : 0.5 - 1 side\\
			Beskrivelse af flowet gennem programmet\\
			UML/Klasse diagram\\
			
		\subsection{Classes and responsibility}
			length : 0.5 - 1 side\\
			Kort beskrivelse af hver klasse plus deres ansvar\\
			
		\subsection{Errorhandling}
			A good idea to handle exceptions is to form somekind of strategy or policy. This helps to a more streamlined errorhandling
			when the program is written, but also if the program is to be expanded at some point. A very simple policy that one could decide, is to
			simply handle the exception exactly where it's created. This would be easy to implement and since this is the most standard way of dealing with
			exceptions, most programmers would know this policy and therefore wouldn't have any objections towards it. On the other hand, it is hard to see, from
			the outside, where and how the an exception is handled and therefore also very hard to make a real policy for, specially when it comes to expansion.\
			When starting to form such a policy, one very central thing, is the ability to predict which kind of errors and exceptions that can and will 
			occur in the program. We have divided our errors and exceptions into tree areas. There is always a potential of startup-files missing, a loss of internet and many others like these two, that can cause a server to being unable to start. All this is put into the area of 'startup'-errors. The next area are errors that can happend any other time after the point of startup. These a called 'server-runtime' errors. This could be a case, where the program usage of ram exceeds the allowed maximum. The last is called 'client'-errors. These types of errors a only errors that can be caused by the client. This could for example be bad input or missing input.  Because of the different times that errors can occur and the level of criticalness, it's clear that they each require different handling. \
			To overcome this we will make a hierachy of exceptions classes, each for one of the tree types of errors. The idea with our own exceptions classes is that we will 'wrap' the actual exception and pass either one of the above mentioned exception to a central errrorhandling class, which will hold the responsibility of dealing which all exceptions. This will remove errorhandling responsibility from both the actual class, where the exception is thrown and from the controller class, which only passes the exceptions to the errorhandling class.\
			In the errorhandling class will be tree types of methods and a reference to an enum class called 'StatusCode'. Since we need to handle the tree types of errors different, we decided to do so, by having tree different methods. For example no matter what kind of server-runtime exception the errorhandler class receives, it will always deal with it the same way, since it always will be the method for server-runtime exceptions that are called. The same goes for the two other exceptions classes.\
			The advantages of doing it this way, is the overview and the easy way of expanding the system. All exceptions will be located in the StatusCode enum and inside the errorhandler class it's possible to see how each type of exception is handled. Futhermore since every exception has to be wrapped inside our own exceptions classes, a programmer i forced to decide how a possible error or exception should be handled and then use either 'server-runtime'-, 'serverstartup'- or 'client'-exceptions. Then he will make a new statuscode for this new error and then will the controller and errorhandler class take care of the rest. 
			
			
			
			
			
			
	\section{Technical Description}
		length : 0.5 - 1 side\\
		Beskrivelse af nogen af de meget tekniske og 'tunge' metoder\\
		
	\section{User Manual}
		length : 0.5 - 1\\
		Er der noget brugeren skal goere for at programmet kan koere? - koder, filer, plugin?\\
		Hvilken browser skal der bruges?\\
		Hvordan skal brugeren koere programmet?\\
		
	\section{Testing}
		length : 0.5 - 1 side\\
		Generelle overvejelser omkring test\\
		Har vi fokuseret på noget specielt i forbindelse med vores test?\\
		
		\subsection{Whitebox}
			length : 0.5 - 1 side\\
			Vi laver kun det her paa en del af programmet - hvorfor har vi valgt lige netop denne del?\\
			
		\subsection{Blackbox}
			
		\subsection{JUnit}
			
		\subsection{Errors, bugs and list of needs}
			length : 1 - 2 sider\\
			Har vi nogle fejl/bugs - Hvilke?\\
			Hvorfor er de fejl/bugs i programmet - kan vi fjerne dem?\\
			Hvad har de af konsekvenser for programmet?\\
			Hvis vi havde mere tid, hvad ville vi så have brugt den på - fejl/bugs kontra mangler??\\
			
		\subsection{Results}
			length : 0.5 side\\
			Forventningstabeller?\\
			Hvad kan vi bruge de her test til i forhold til programmet?\\
			
	\section{Product conclusion}
		length : 1 - 2 sider\\
		Har vi indfriet de krav til programmet, som vi omtalte i tidligere afsnit?\\
		Hvad ville vi goere anderleds, hvis vi havde muligheden?\\
		Mangler der noget, for at vi kan sende det her program paa gaden?\\
		
	\section{Process description}
		lenght : 1 - sider\\
		This part of the report is a reflection of the internal workprocess in the group. It will try to explain how the proces has been and what went good and what things that didn't work as good as it should have. \\
		For this project we were put into group by our teachers, which both have up- and downsides. One of the best things by doing it that way, is the individual qualities that each member posses and can bring to the group. On the other hand, this also means that every group member have very different programming experience and ambitions for the project. To overcome this we decided, on the first group meeting, that we needed some kind of 'contract' for the collaboration and the ambitions toward the final product and exam. The result of this meeting was a collaboration agreement, which can be viewed in the appendix. Underway in the project we haven't used the collaboration agreement, but we believe that it has always remained in our conscious, which have been important. For example we were discussion what kind of features, that we wanted to implement. From the start we all agreed on to limit features and instead focus on the basic requirements and making those work. We put this in the collaboration agreement and even though, we haven't discussed it, it has never been hard to agree on if we should have a speciel feature or not. All of this due to our collaboration agreement and discussion about ambitions.\
		To enhance the collaboration process, we decided on a early state to use somekind of revision control. 
		Tidsplan
		GIT
		Meeting structure
		
		Hvordan er samarbejdet gaet i gruppen?\
		Hvad kunne vi goere for at faet et bedre samarbejde?\
		Hvad/hvilke ting var gode/daarlige i gruppen?\
		Har vi brugt nogle vaerktoejer til at styrke vores samarbejde? Kunne vi have brugt nogen?\
		
	
	\section{Final thoughts}
		length : 0.5 - 1 side\\
		Skal bare lige runde projektet af..
	
	\section{Appendix}
		
		
\end{document}