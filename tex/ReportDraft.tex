\documentclass[a4paper,10pt,titlepage]{article}
\usepackage{graphicx}
\begin{document}
	\tableofcontents
	\newpage
	\section{Preface}
		This project and report is made by Jakob Bang Helvind, Kasra Tahmasebi Shahrebabak, Mark Thorhauge, Filip Hjermind Jensen, Lars Yndal Sørensen og
		Anders Brorup Jørgensen. It was written for the course ’First-Year Project’ on the bachelor ”Software Development” in the Spring of 2012 at the
		IT-University of Denmark. The report is written in terms, that we believe fellow students possesses and will understand. We hope that this 
		report will give insight in the workprocess as well as the product and that all readers will enjoy reading it.\\
		MAALGRUPPE !! ! 
	
	\section{Background and Data}
		length : 0.5 - 1 side\\
		For this project we have been given the task of designing and creating a java-written program 
		for the exam in the course 'First-Year-Project' on 2nd semester in the bachelorprogram. The basic idea of the 
		program is, that it should use some existing mapdata of Denmark to visualize a map of Denmark and let the user be
		able to search and see a given route. 
		\\This dataset is from the danish mapprovider Krak.dk and it consists of two text files. A file with all the points 
		and a file with all connections between these points.  
		\\The application should meet the following requirements:
		\\	- Draw all roads in the dataset
		\\	- The map-visualization should adjust acordingly to changes of the windows size
		\\	- The user should be able to navigate in the visualization
		\\	- The application should have a minimum of clutter and therefore be able to set a priority of the roads
		\\	- Be able to compute and show the shortest path between two points given by the user
		\\	- The application should have a logical, consistent and reasonable fast and responsive user interface\\
		
		In other words, a user should be able to see a map of Denmark with a selective amount of major roads, then explore
		 this map by zooming in and out, and otherwise navigating around. A user should also be able to select two adresses,
		 and get the shortest route between these two points calculated and shown on the map, with the map cut out to a
		 fitting view of the route.
	\section{Problemanalysis}
		\subsection{Requirements}
		length : 1-3 sider\\
		Analyse af de krav, som er beskrevet i foregående afsnit\\
		Hvad skal vi have med i vores program, for at vi kan indfri disse krav?\\
		Hvilke ting vil i have fokus paa - hastighed, hukommelse, brugervenlighed, udvidelsesmuligheder etc.?\\
		hvorfor har vi valgt edges og road objekter istedet for at holde det samlet?
		
		
		\subsection{Thoughts toward design}
			length : 0.5 side\\
			Opsummering af foregående afsnit omkring analyse af samt en præcisering af kravene. Men dette afsnit, skal bare bruges som indledning. 
			\subsubsection{Datastructure}
				length : 1 - 2 side\\
				Hvilke generelle overvejelser er skal der tager i forbindelse med valg af datastruktur? \\
				Hvor mange har vi brug - hvilke krav er der til hver enkelt?\\
				Hvorfor har vi valgt lige netop denne datastruktur - Hvilke af vores krav indfrier de?\\
				Alternativer - Fordele / ulemper?\\

				As the application should be able to visualize regions of a map, and calculate the shortest path between two points, it is viable to have both one and two data structures. Both functions require vertices and edges, but the requirements for the objects are different for the two. The shortest path function is fastest with shortened and directed roads, while visualization needs the original data to display the curves of the roads and does not need direction on the edges. To avoid any compromises to the performance of the functions and to allow further development of both functions in different directions, two data structures are made, one for each algorithm. This will greatly increase memory usage and startup time, but as performance is higher priority, this is the choice that fulfills the requirements the most.

The visualization data structure
 
The type of data to be stored, should be considered as much as the data structure. Either the data could be roads with two points, a type and a priority, or it could be nodes with a point and references to road objects that it represents. As we want to draw roads and not nodes, it would be the most memory saving decision to store roads. However roads impose a complex problem, that is when searching for them(a range search) they should be returned when one or two of their coordinates are within the range. When storing roads in a grid file or a kd-tree, a road would appear twice because it has two points, making it very likely to return it twice when doing a range search. With around a million roads, filtering all similar roads requires another data structure and an appurtenant algorithm, which will slow down the search process. To avoid this complexity, roads could be referenced at only one of their points. This removes the possibility to return the same road twice, but imposes another problem. The illustration below shows roads, which are stored as points(the circles at the end of the line) and a range. When
\includegraphics{../../../Desktop/epsRoadDS} searching in this range, all the roads should be returned. With roads referenced as a single point, R2 would not be returned, but R1 would. R3 would never be returned, even when referenced by two points. To solve this, an extra part of the map could be loaded, increasing the width and height of the rectangle by x, where x is the longest road in the map. Of course this would be inefficient if the roads’ length is not systematically broken down, and this would require the data to be restructured. To be able to guarantee that all roads within an area are shown, we will need to take this approach for that particular solution.
The node has references to the roads that it is a part of. Storing nodes in the data structure has the same problem as storing roads referenced by two points. The difference is that nodes require more memory because an object is created for each one, but it makes the data structure contain less elements. As there are fewer nodes than road endpoints, it makes the kd-tree(discussed later in this chapter) more shallow, and therefore faster. 
The most important requirement for our data structure is that it should be fast, while memory usage and startup time is less important. When looking at smaller parts of the map the improvement should be most significant. We chose the kd-tree because its binary structure and adaptive construction makes it efficient to access data, no matter how much it clumps(how numerically close the keys are to each other). While grid-file is potentially faster, the kd-tree is stable and does not depend on bucket size or other factors such as cluttering. Also one of the kd-tree’s weaknesses is to return data from a rectangular query, which our aspect ratio does not allow, making it very suitable for our problem. We chose nodes as data objects because it is easier to implement, but to our best knowledge, roads referenced by one point should be the fastest and best solution.

Algorithms
Two-dimensional range search
The algorithm used to search in the kd-tree should be as fast as the kd-tree allows it to. The data structure has an associated algorithm, which runs in logarithmic time making it very suitable for large data sets.
Construction of the kd-tree requires a median finding function, which is used balancing the tree. The algorithm is not required to find the median, but it makes the tree shallower the closer it comes to the true median. The choice is either a median finding algorithm that runs in amortized linear time or an algorithm based on random picking elements to sort and find the median from. The first is much slower when constructing the tree, but makes the search faster. Empirical testing reveals that the difference in search time is very small when switching between the two ways of constructing the tree. Because the difference is small when searching and big when constructing the tree, we chose the random algorithm.

				
			\subsubsection{Algorithms}
				length : 1 - 2 side\\
				Hvilke generelle overvejelser er der ved valg af algoritmer?\
				Hvad skal vi bruge den/dem til i vores program - Hvilke problem løser de/Hvilke er vores krav indfrier de?\\
				Hvilken algoritme har vi valgt? - Hvorfor lige netop denne?\\
				Alternativer?\\
								
			\subsubsection{User Interface}
				length : 1 - 2 side\\
				Hvilke krav har vi til brugerfladen??\\
				Hvorfor bruger vi JS/Browser og ikke java Swing??\\
				
				In this section we will discuss different ways that the user interface could be implemented. We will start off by discussing the overall decisions such as which technology we should use to show the data graphically. After that we will move towards a discussion of the features we will implement and how it should be done.  

The requirement for the user interface is formulated in the project description as follows: "Design a coherent user interface, which includes the map, but probably also other components". To fulfull this requirement we have to first of all select a technology to show graphical data for the user. In our case there are two obvious options. The first one is to use Swing and the other one is to make a browser based solution. In the following we will discuss both solutions.

\paragraph{Swing Solution}
We will mention two advantages of using the Swing API. First advantage is that we will be able to use an advanced programming language. Using Java rather than Java Script will i.a. give us typesafty, a comprehensive standard library, chance for errorhandling and inheritance just to mention a few. The second advantage is that it will be easier to implement extra features because we already know the Java language and the Swing API. Using Swing also have som disadvantages and we will mention two. The first disadvantage is that the user will need a JVM to run the program. It is not difficult to download and install the JVM, but it is more convenient for the standard user to use a browser. The second disadvantage is that if the entire functionality is located in one program then the user will experience a long waitingtime every time the program starts up. Contrary there will be no startuptime for the user when using the browser solution. 

\paragraph{Browser solution}
For the browser solution we will also mention two advantages. The first one is that long startup time and memory usage is acceptable for the server part because this part is running on a powerful computer and the user will not experiece this startuptime. That gives us the possibility to favor performance over memoryusage. The second advantage is that we will acquire knowledge about javascript, xml and svg, which are widespread technologies. We will also mention two disadvantages. The first one is that we have limited acces to the implementation. We don't know how the different browsers implements the different svg commands and therefore we have no possibility of improving performance in that part of the program. The other disadvantage is time consumption. Chosing a browser solution involves knowledge about a wide range of technologies such as HTMLl, CSS, Javascript, XPath, XML, SVG and HTTP. None of the group members had in depth knowledge about these technolgies beforehand.    

Based on the different advantages and disadvantages we have chosen the browser solution. The fact that we can focus on performance rather than memoryusage, that the browser solution is more userfriendly and that we get the chance to learn new technologies leads us to that descision.

\paragraph{Features}
The second step in fulfilling the above mentioned requirement is to analyze how we, by using a browser, can make a coherent userinterface. Therefore we have to discuss which features should be implemented and how these features should be implemented, e.g. decide how much of the functionality should be located in the browser and how much should be located at the server. In the following we will discuss the different features.
\paragraph{Road displaying}
To show the roads we have the option of using plain Java Sript or to use a combination of Java Script and svg. The advantage of using plain Java Script is that we would have the abillity to completely control the drawing of the roads and maybe optimize performance. The advantage of using SVG is that SVG supports a wide range of functionality and therefore we could save some time. Futhermore SVG seams to become a widely recognised technology, which means that more people might be able to understand and use our program in other contexts. Our choice fell on the combined solution with both Java Script and SVG. 
 
\paragraph{Scalable map}
The map needs to be scalable when the user drags the window. In our case that functionality comes for free when we use SVG. The only thing we need to consider is how SVG should show the map. Basicly there are to ways. One way is to always let all of the viewport be visible no matter what aspect ratio the user will create when draging the window. This will create a white border in the top and down or in the left and right. Another way is to cut of the map so that the map always takes up all the space. We chose the last solution because it make use of all of the available space in the browser window. The only disadvantage is that when the user use the routeplanning it might not be possible to show the entire route if the aspect ratio is very wide or narrow. 

\paragraph{Zoom and panning}
When discussing zoom and panning there are two aspects. The first one is to consider how much extra data should be passed from the server to the browser. We have chosen to call that extra data for buffer data. When choosing the amount of buffer data there are to extremes. The first one is to let the browser request exactly that amount of data that the user is requesting. This way of doing it would make sure that it would be easy to develop a new view, e.g. a smartphone app, because most of the functionality is located at the server. On the other hand the user might experience the program as slow if the user has a slow internet connection. The other extreme is to let the browser request all data in one call and only show what the user is asking for. This would require a lot of functionality in the view, but it might result in a good experience for the user if the internet connection is slow. We have chosen a compromize where the browser request buffer data for panning and not for zooming.
The other aspect is to decide in what way the user should be able to zoom and pan. Since we know that it takes a long time to get the Java Script, HTML, SVG and XPath to work together we have chosen to settle for buttons in the browser as the only way for the user to navigate in the map. One could consider to make it possible for the user to use keyboard shortcuts and mouseevents for zooming and panning. 

\paragraph{Routeshowing}
There are to different approches of showing the route when the user zooms or pans after a routesearch. The first approach is to request the server for more map data and the same route. This approach is good because it keeps functionality at the server but it can be slow if for instance the user asks for a route from Copenhagen to Skagen, because the Dijkstra algorithm would be ran every time. The other approach is to save the route in the browser, which is relatively uncomplicated when using SVG. The last approach is the one we chose.	

				
				
		\subsection{Summary}
			length : 0.5 - 1 side\\
			Opsummering\\
			Kan vi indfri vores krav/maal for programmet, ved at bruge de ting, som vi har beskrevet i det her afsnit??\\
			
	\section{Implementation}
		length : 0.5 - 1 side\\
		Her beskrives kort hvad der kommer til at være i det kommende afsnit..
		
		\subsection{Flow description}
			length : 0.5 - 1 side\\
			Beskrivelse af flowet gennem programmet\\
			UML/Klasse diagram\\
			
		\subsection{Classes and responsibility}
			length : 0.5 - 1 side\\
			Kort beskrivelse af hver klasse plus deres ansvar\\
<<<<<<< HEAD
			KDTree
			The KDTree class is responsible for creating the data structure and implementing the search algorithm for range searches. The KDTree contains nodes, which are the input and output type. The output from the search function is used by the RoadSelector class. 
=======
			
		\subsection{Errorhandling}
			A good idea to handle exceptions is to form somekind of strategy or policy. This helps to a more streamlined errorhandling
			when the program is written, but also if the program is to be expanded at some point. A very simple policy that one could decide, is to
			simply handle the exception exactly where it's created. This would be easy to implement and since this is the most standard way of dealing with
			exceptions, most programmers would know this policy and therefore wouldn't have any objections towards it. On the other hand, it is hard to see, from
			the outside, where and how the an exception is handled and therefore also very hard to make a real policy for, specially when it comes to expansion.\
			When starting to form such a policy, one very central thing, is the ability to predict which kind of errors and exceptions that can and will 
			occur in the program. We have divided our errors and exceptions into tree areas. There is always a potential of startup-files missing, a loss of internet and many others like these two, that can cause a server to being unable to start. All this is put into the area of 'startup'-errors. The next area are errors that can happend any other time after the point of startup. These a called 'server-runtime' errors. This could be a case, where the program usage of ram exceeds the allowed maximum. The last is called 'client'-errors. These types of errors a only errors that can be caused by the client. This could for example be bad input or missing input.  Because of the different times that errors can occur and the level of criticalness, it's clear that they each require different handling. \
			To overcome this we will make a hierachy of exceptions classes, each for one of the tree types of errors. The idea with our own exceptions classes is that we will 'wrap' the actual exception and pass either one of the above mentioned exception to a central errrorhandling class, which will hold the responsibility of dealing which all exceptions. This will remove errorhandling responsibility from both the actual class, where the exception is thrown and from the controller class, which only passes the exceptions to the errorhandling class.\
			In the errorhandling class will be tree types of methods and a reference to an enum class called 'StatusCode'. Since we need to handle the tree types of errors different, we decided to do so, by having tree different methods. For example no matter what kind of server-runtime exception the errorhandler class receives, it will always deal with it the same way, since it always will be the method for server-runtime exceptions that are called. The same goes for the two other exceptions classes.\
			The advantages of doing it this way, is the overview and the easy way of expanding the system. All exceptions will be located in the StatusCode enum and inside the errorhandler class it's possible to see how each type of exception is handled. Futhermore since every exception has to be wrapped inside our own exceptions classes, a programmer i forced to decide how a possible error or exception should be handled and then use either 'server-runtime'-, 'serverstartup'- or 'client'-exceptions. Then he will make a new statuscode for this new error and then will the controller and errorhandler class take care of the rest. 
			
			
			
			
			
>>>>>>> branch 'part2' of https://markthor@github.com/kasraman1000/KrakProjekt.git
			
	\section{Technical Description}
		length : 0.5 - 1 side\\
		Beskrivelse af nogen af de meget tekniske og 'tunge' metoder\\
Creation of the data structure is done by calling the expand method on a KDNode object, which will construct the tree recursively. The KDNode is a nested class, which serves as a container for the real node object. Each KDNode has references to its child nodes, the left is smaller than the nodes relevant coordinate and the right one is greater or equal to. The expand method finds the median node from the input collection and returns that node as the child node. It calls the same method twice, each with approximately half of the collection it was given, divided by the median node. By changing the axis, which the median is calculated from, a two dimensional tree is constructed.
Searching in the tree is done from a region input. When visiting a node, a region is defined from the axis, which the node was chosen as median from. For instance the first node (root node) defines two regions that ranges from the largest to the smallest y-coordinate. The left region for this node ranges from the smallest x-coordinate to the nodes x-coordinate and the right ranges from the biggest x-coordinate to the nodes x-coordinate. For both regions the geometrical functions fullyContained and intersecting investigates how they relate to the input region. If the region is fully contained in the input region it returns all child nodes. If it is intersecting, this function is called recursively.

		
	\section{User Manual}
		length : 0.5 - 1\\
		Er der noget brugeren skal goere for at programmet kan koere? - koder, filer, plugin?\\
		Hvilken browser skal der bruges?\\
		Hvordan skal brugeren koere programmet?\\
		
	\section{Testing}
		length : 0.5 - 1 side\\
		Generelle overvejelser omkring test\\
		Har vi fokuseret på noget specielt i forbindelse med vores test?\\
		
		\subsection{Whitebox}
			length : 0.5 - 1 side\\
			Vi laver kun det her paa en del af programmet - hvorfor har vi valgt lige netop denne del?\\
			
		\subsection{Blackbox}
			
		\subsection{JUnit}
			
		\subsection{Errors, bugs and list of needs}
			length : 1 - 2 sider\\
			Har vi nogle fejl/bugs - Hvilke?\\
			Hvorfor er de fejl/bugs i programmet - kan vi fjerne dem?\\
			Hvad har de af konsekvenser for programmet?\\
			Hvis vi havde mere tid, hvad ville vi så have brugt den på - fejl/bugs kontra mangler??\\
			
		\subsection{Results}
			length : 0.5 side\\
			Forventningstabeller?\\
			Hvad kan vi bruge de her test til i forhold til programmet?\\
			
	\section{Product conclusion}
		length : 1 - 2 sider\\
		Har vi indfriet de krav til programmet, som vi omtalte i tidligere afsnit?\\
		Hvad ville vi goere anderleds, hvis vi havde muligheden?\\
		Mangler der noget, for at vi kan sende det her program paa gaden?\\
		
	\section{Process description}
		lenght : 1 - sider\\
		This part of the report is a reflection of the internal workprocess in the group. It will try to explain how the process has been and what went good and what things that didn't work as good as it should have. \\
		For this project we were put into group by our teachers, which both have up- and downsides. One of the best things by doing it that way, is the individual qualities that each member posses and can bring to the group. On the other hand, this also means that every group member have very different programming experience and ambitions for the project. To overcome this we decided, on the first group meeting, that we needed some kind of 'contract' for the collaboration and the ambitions toward the final product and exam. The result of this meeting was a collaboration agreement, which can be viewed in the appendix. Underway in the project we haven't used the collaboration agreement, but we believe that it has always remained in our conscious, which have been important. For example we were discussion what kind of features, that we wanted to implement. From the start we all agreed on to limit features and instead focus on the basic requirements and making those work. We put this in the collaboration agreement and even though, we haven't discussed it, it has never been hard to agree on if we should have a speciel feature or not. All of this due to our collaboration agreement and discussion about ambitions.\
		We also used another collaboration tool to enhance the collaboration process. This was revision control, which is a powerful tool in larger programming projects. Both github.org and SVN were on the table as ideas, but we decided to go with Git.  \
		Besides the collaboration agreement and the revision control, we also used a schedule to control the work process. This helped us to make some kind of agreement of how much time, we were each devoted to use on the project and in what rate the process should take place. When making this schedule we found ourselves having a disagreement as to when we should stop writing code and when to start working on the report. We found ourselves discussion this for quite some while, since half of the group meant that we should start writing report as soon as possible, along with the code writing. And the other half of the group wanted to start the project by writing code and then in the project make report as the last thing. You could say the both ways have advantages, but when writing report as the last thing, there always a chance of forgetting important discussions and arguments, which always is to document well in a project like this. And because of that, we decided that we wanted to have a period of code freeze, where focus would be on the report. This period was planned to be around midway of the full project period, but this can be viewed more detailed in the appendix, where the schedule can be found. \
		

		Tidsplan
		GIT
		Meeting structure
		
		Hvordan er samarbejdet gaet i gruppen?\
		Hvad kunne vi goere for at faet et bedre samarbejde?\
		Hvad/hvilke ting var gode/daarlige i gruppen?\
		Har vi brugt nogle vaerktoejer til at styrke vores samarbejde? Kunne vi have brugt nogen?\
		
	
	\section{Final thoughts}
		length : 0.5 - 1 side\\
		Skal bare lige runde projektet af..
	
	\section{Appendix}
		
		
\end{document}
